---
apiVersion: helm.toolkit.fluxcd.io/v2
kind: HelmRelease
metadata:
  name: alloy
  namespace: monitoring
spec:
  releaseName: alloy
  chart:
    spec:
      version: 1.3.0
      chart: alloy
      sourceRef:
        kind: HelmRepository
        name: grafana
        namespace: flux-system
  interval: 30m
  timeout: 15m
  install:
    remediation:
      retries: 3
  values:
    alloy:
      configMap:
        create: true
        content: |
          // Cluster-wide service discovery for node metrics
          discovery.kubernetes "nodes" {
            role = "node"
          }

          // Scrape node-exporter metrics
          prometheus.scrape "node_exporter" {
            targets    = discovery.kubernetes.nodes.targets
            forward_to = [prometheus.remote_write.local_mimir.receiver]
            scrape_interval = "15s"
            metrics_path = "/metrics"
            scheme = "http"
            job_name = "node-exporter"
          }

          // Cluster-wide service discovery for pods
          discovery.kubernetes "pods" {
            role = "pod"
          }

          // Scrape application metrics from pods with prometheus annotations
          prometheus.scrape "kubernetes_pods" {
            targets = discovery.relabel.kubernetes_pods.output
            forward_to = [prometheus.remote_write.local_mimir.receiver]
            scrape_interval = "30s"
            job_name = "kubernetes-pods"
          }

          // Relabeling for pod scraping
          discovery.relabel "kubernetes_pods" {
            targets = discovery.kubernetes.pods.targets
            rule {
              source_labels = ["__meta_kubernetes_pod_annotation_prometheus_io_scrape"]
              action = "keep"
              regex = "true"
            }
            rule {
              source_labels = ["__meta_kubernetes_pod_annotation_prometheus_io_path"]
              action = "replace"
              target_label = "__metrics_path__"
              regex = "(.+)"
            }
            rule {
              source_labels = ["__address__", "__meta_kubernetes_pod_annotation_prometheus_io_port"]
              action = "replace"
              regex = "([^:]+)(?::\\d+)?;(\\d+)"
              replacement = "$1:$2"
              target_label = "__address__"
            }
            rule {
              action = "labelmap"
              regex = "__meta_kubernetes_pod_label_(.+)"
            }
            rule {
              source_labels = ["__meta_kubernetes_namespace"]
              action = "replace"
              target_label = "kubernetes_namespace"
            }
            rule {
              source_labels = ["__meta_kubernetes_pod_name"]
              action = "replace"
              target_label = "kubernetes_pod_name"
            }
          }

          // Service discovery for services
          discovery.kubernetes "services" {
            role = "service"
          }

          // Scrape service metrics
          prometheus.scrape "kubernetes_services" {
            targets = discovery.relabel.kubernetes_services.output
            forward_to = [prometheus.remote_write.local_mimir.receiver]
            scrape_interval = "30s"
            job_name = "kubernetes-services"
          }

          // Relabeling for service scraping
          discovery.relabel "kubernetes_services" {
            targets = discovery.kubernetes.services.targets
            rule {
              source_labels = ["__meta_kubernetes_service_annotation_prometheus_io_scrape"]
              action = "keep"
              regex = "true"
            }
            rule {
              source_labels = ["__meta_kubernetes_service_annotation_prometheus_io_path"]
              action = "replace"
              target_label = "__metrics_path__"
              regex = "(.+)"
            }
            rule {
              source_labels = ["__address__", "__meta_kubernetes_service_annotation_prometheus_io_port"]
              action = "replace"
              regex = "([^:]+)(?::\\d+)?;(\\d+)"
              replacement = "$1:$2"
              target_label = "__address__"
            }
            rule {
              action = "labelmap"
              regex = "__meta_kubernetes_service_label_(.+)"
            }
            rule {
              source_labels = ["__meta_kubernetes_namespace"]
              action = "replace"
              target_label = "kubernetes_namespace"
            }
            rule {
              source_labels = ["__meta_kubernetes_service_name"]
              action = "replace"
              target_label = "kubernetes_service_name"
            }
          }

          // Remote write to local Mimir
          prometheus.remote_write "local_mimir" {
            endpoint {
              url = "http://mimir-gateway.monitoring.svc.cluster.local/api/v1/push"
            }
            external_labels = {
              cluster = "my-cluster",
              source = "alloy",
            }
          }

          // Kubernetes log collection
          discovery.kubernetes "pods_logs" {
            role = "pod"
          }

          // Pod logs collection
          loki.source.kubernetes "pod_logs" {
            targets    = discovery.kubernetes.pods_logs.targets
            forward_to = [loki.write.local_loki.receiver]
          }

          // Kubernetes events collection
          loki.source.kubernetes_events "cluster_events" {
            forward_to = [loki.write.local_loki.receiver]
          }

          // Remote write to local Loki
          loki.write "local_loki" {
            endpoint {
              url = "http://loki-gateway.monitoring.svc.cluster.local/loki/api/v1/push"
            }
            external_labels = {
              cluster = "my-cluster",
              source = "alloy",
            }
          }
    controller:
      type: "daemonset"