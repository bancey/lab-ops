---
apiVersion: helm.toolkit.fluxcd.io/v2
kind: HelmRelease
metadata:
  name: alloy
  namespace: monitoring
spec:
  values:
    alloy:
      configMap:
        content: |
          // Cluster-wide service discovery for node metrics
          discovery.kubernetes "nodes" {
            role = "node"
          }

          // Scrape node-exporter metrics
          prometheus.scrape "node_exporter" {
            targets    = discovery.relabel.node_exporter.output
            forward_to = [prometheus.remote_write.local_mimir.receiver]
            scrape_interval = "15s"
            metrics_path = "/metrics"
            scheme = "http"
            job_name = "node-exporter"
            honor_timestamps = false
            scrape_timeout = "10s"
          }

          // Relabeling for node exporter to ensure consistent labels
          discovery.relabel "node_exporter" {
            targets = discovery.kubernetes.nodes.targets

            // Add cluster label consistently
            rule {
              target_label = "cluster"
              replacement = "tiny"
            }

            // Add unique source identifier to prevent conflicts
            rule {
              target_label = "alloy_instance"
              replacement = "tiny-alloy"
            }

            // Ensure instance label is consistent and unique
            rule {
              source_labels = ["__meta_kubernetes_node_name"]
              target_label = "instance"
              replacement = "tiny-${1}"
            }

            // Add node role label
            rule {
              source_labels = ["__meta_kubernetes_node_label_node_kubernetes_io_instance_type"]
              target_label = "node_type"
              regex = "(.+)"
            }

            // Set the address for node-exporter (assuming it runs on port 9100)
            rule {
              source_labels = ["__meta_kubernetes_node_address_InternalIP"]
              target_label = "__address__"
              replacement = "${1}:9100"
            }
          }

          // Cluster-wide service discovery for pods
          discovery.kubernetes "pods" {
            role = "pod"
          }

          // Scrape application metrics from pods with prometheus annotations
          prometheus.scrape "kubernetes_pods" {
            targets = discovery.relabel.kubernetes_pods.output
            forward_to = [prometheus.remote_write.local_mimir.receiver]
            scrape_interval = "30s"
            job_name = "kubernetes-pods"
            honor_timestamps = false
            scrape_timeout = "25s"
          }

          // Relabeling for pod scraping
          discovery.relabel "kubernetes_pods" {
            targets = discovery.kubernetes.pods.targets

            // Ensure cluster label is consistent
            rule {
              target_label = "cluster"
              replacement = "tiny"
            }

            rule {
              source_labels = ["__meta_kubernetes_pod_annotation_prometheus_io_scrape"]
              action = "keep"
              regex = "true"
            }
            rule {
              source_labels = ["__meta_kubernetes_pod_annotation_prometheus_io_path"]
              action = "replace"
              target_label = "__metrics_path__"
              regex = "(.+)"
            }
            rule {
              source_labels = ["__address__", "__meta_kubernetes_pod_annotation_prometheus_io_port"]
              action = "replace"
              regex = "([^:]+)(?::\\d+)?;(\\d+)"
              replacement = "$1:$2"
              target_label = "__address__"
            }
            rule {
              action = "labelmap"
              regex = "__meta_kubernetes_pod_label_(.+)"
            }
            rule {
              source_labels = ["__meta_kubernetes_namespace"]
              action = "replace"
              target_label = "kubernetes_namespace"
            }
            rule {
              source_labels = ["__meta_kubernetes_pod_name"]
              action = "replace"
              target_label = "kubernetes_pod_name"
            }
          }

          // Service discovery for services
          discovery.kubernetes "services" {
            role = "service"
          }

          // Scrape service metrics
          prometheus.scrape "kubernetes_services" {
            targets = discovery.relabel.kubernetes_services.output
            forward_to = [prometheus.remote_write.local_mimir.receiver]
            scrape_interval = "30s"
            job_name = "kubernetes-services"
            honor_timestamps = false
            scrape_timeout = "25s"
          }

          // Relabeling for service scraping
          discovery.relabel "kubernetes_services" {
            targets = discovery.kubernetes.services.targets

            // Ensure cluster label is consistent
            rule {
              target_label = "cluster"
              replacement = "tiny"
            }

            rule {
              source_labels = ["__meta_kubernetes_service_annotation_prometheus_io_scrape"]
              action = "keep"
              regex = "true"
            }
            rule {
              source_labels = ["__meta_kubernetes_service_annotation_prometheus_io_path"]
              action = "replace"
              target_label = "__metrics_path__"
              regex = "(.+)"
            }
            rule {
              source_labels = ["__address__", "__meta_kubernetes_service_annotation_prometheus_io_port"]
              action = "replace"
              regex = "([^:]+)(?::\\d+)?;(\\d+)"
              replacement = "$1:$2"
              target_label = "__address__"
            }
            rule {
              action = "labelmap"
              regex = "__meta_kubernetes_service_label_(.+)"
            }
            rule {
              source_labels = ["__meta_kubernetes_namespace"]
              action = "replace"
              target_label = "kubernetes_namespace"
            }
            rule {
              source_labels = ["__meta_kubernetes_service_name"]
              action = "replace"
              target_label = "kubernetes_service_name"
            }
          }

          // Remote write to local Mimir
          prometheus.remote_write "local_mimir" {
            endpoint {
              url = "http://mimir-gateway.monitoring.svc.cluster.local/api/v1/push"

              // Add headers for better debugging
              headers = {
                "X-Scope-OrgID" = "anonymous"
              }
            }

            // Add queue configuration to handle out-of-order samples
            queue_config {
              capacity = 10000
              max_samples_per_send = 2000
              batch_send_deadline = "5s"
              min_shards = 1
              max_shards = 10
              retry_on_http_429 = true
            }

            external_labels = {
              cluster = "tiny",
              source = "alloy-tiny",
              alloy_instance = "tiny-cluster",
            }

            // Add metadata configuration
            metadata_config {
              send = true
              send_interval = "1m"
            }
          }

          // Kubernetes log collection
          discovery.kubernetes "pods_logs" {
            role = "pod"
          }

          // Pod logs collection
          loki.source.kubernetes "pod_logs" {
            targets    = discovery.kubernetes.pods_logs.targets
            forward_to = [loki.write.local_loki.receiver]
          }

          // Kubernetes events collection
          loki.source.kubernetes_events "cluster_events" {
            forward_to = [loki.write.local_loki.receiver]
          }

          // Remote write to local Loki
          loki.write "local_loki" {
            endpoint {
              url = "http://loki-gateway.monitoring.svc.cluster.local/loki/api/v1/push"
            }
            external_labels = {
              cluster = "tiny",
              source = "alloy-tiny",
            }
          }