---
apiVersion: helm.toolkit.fluxcd.io/v2
kind: HelmRelease
metadata:
  name: alloy
  namespace: monitoring
spec:
  values:
    controller:
      tolerations:
        - key: node-role.kubernetes.io/control-plane
          operator: Exists
          effect: NoExecute
        - key: node-role.kubernetes.io/master
          operator: Exists
          effect: NoExecute
    alloy:
      configMap:
        content: |
          // Cluster-wide service discovery for node metrics
          discovery.kubernetes "nodes" {
            role = "node"
          }

          // Scrape node-exporter metrics
          prometheus.scrape "node_exporter" {
            targets    = discovery.relabel.node_exporter.output
            forward_to = [prometheus.remote_write.mimir.receiver]
            scrape_interval = "15s"
            metrics_path = "/metrics"
            scheme = "http"
            job_name = "node-exporter"
            honor_timestamps = false
            scrape_timeout = "10s"
          }

          // Relabeling for node exporter to ensure consistent labels and prevent conflicts
          discovery.relabel "node_exporter" {
            targets = discovery.kubernetes.nodes.targets

            // Add cluster label consistently
            rule {
              target_label = "cluster"
              replacement = "wanda"
            }

            // Add unique source identifier to prevent conflicts
            rule {
              target_label = "alloy_instance"
              replacement = "wanda-alloy"
            }

            // Ensure instance label is consistent and unique
            rule {
              source_labels = ["__meta_kubernetes_node_name"]
              target_label = "instance"
              replacement = "wanda-${1}"
            }

            // Add node role label
            rule {
              source_labels = ["__meta_kubernetes_node_label_node_kubernetes_io_instance_type"]
              target_label = "node_type"
              regex = "(.+)"
            }

            // Set the address for node-exporter (assuming it runs on port 9100)
            rule {
              source_labels = ["__meta_kubernetes_node_address_InternalIP"]
              target_label = "__address__"
              replacement = "${1}:9100"
            }
          }

          // Cluster-wide service discovery for pods
          discovery.kubernetes "pods" {
            role = "pod"
          }

          // Scrape application metrics from pods with prometheus annotations
          prometheus.scrape "kubernetes_pods" {
            targets = discovery.relabel.kubernetes_pods.output
            forward_to = [prometheus.remote_write.mimir.receiver]
            scrape_interval = "30s"
            job_name = "kubernetes-pods"
            honor_timestamps = false
            scrape_timeout = "25s"
          }

          // Relabeling for pod scraping
          discovery.relabel "kubernetes_pods" {
            targets = discovery.kubernetes.pods.targets

            // Ensure cluster label is consistent
            rule {
              target_label = "cluster"
              replacement = "wanda"
            }

            rule {
              source_labels = ["__meta_kubernetes_pod_annotation_prometheus_io_scrape"]
              action = "keep"
              regex = "true"
            }
            rule {
              source_labels = ["__meta_kubernetes_pod_annotation_prometheus_io_path"]
              action = "replace"
              target_label = "__metrics_path__"
              regex = "(.+)"
            }
            rule {
              source_labels = ["__address__", "__meta_kubernetes_pod_annotation_prometheus_io_port"]
              action = "replace"
              regex = "([^:]+)(?::\\d+)?;(\\d+)"
              replacement = "$1:$2"
              target_label = "__address__"
            }
            rule {
              action = "labelmap"
              regex = "__meta_kubernetes_pod_label_(.+)"
            }
            rule {
              source_labels = ["__meta_kubernetes_namespace"]
              action = "replace"
              target_label = "kubernetes_namespace"
            }
            rule {
              source_labels = ["__meta_kubernetes_pod_name"]
              action = "replace"
              target_label = "kubernetes_pod_name"
            }
          }

          // Service discovery for services
          discovery.kubernetes "services" {
            role = "service"
          }

          // Scrape service metrics
          prometheus.scrape "kubernetes_services" {
            targets = discovery.relabel.kubernetes_services.output
            forward_to = [prometheus.remote_write.mimir.receiver]
            scrape_interval = "30s"
            job_name = "kubernetes-services"
            honor_timestamps = false
            scrape_timeout = "25s"
          }

          // Relabeling for service scraping
          discovery.relabel "kubernetes_services" {
            targets = discovery.kubernetes.services.targets

            // Ensure cluster label is consistent
            rule {
              target_label = "cluster"
              replacement = "wanda"
            }

            rule {
              source_labels = ["__meta_kubernetes_service_annotation_prometheus_io_scrape"]
              action = "keep"
              regex = "true"
            }
            rule {
              source_labels = ["__meta_kubernetes_service_annotation_prometheus_io_path"]
              action = "replace"
              target_label = "__metrics_path__"
              regex = "(.+)"
            }
            rule {
              source_labels = ["__address__", "__meta_kubernetes_service_annotation_prometheus_io_port"]
              action = "replace"
              regex = "([^:]+)(?::\\d+)?;(\\d+)"
              replacement = "$1:$2"
              target_label = "__address__"
            }
            rule {
              action = "labelmap"
              regex = "__meta_kubernetes_service_label_(.+)"
            }
            rule {
              source_labels = ["__meta_kubernetes_namespace"]
              action = "replace"
              target_label = "kubernetes_namespace"
            }
            rule {
              source_labels = ["__meta_kubernetes_service_name"]
              action = "replace"
              target_label = "kubernetes_service_name"
            }
          }

          // Remote write to Mimir on tiny cluster
          prometheus.remote_write "mimir" {
            endpoint {
              url = "https://mimir.tiny.heimelska.co.uk/api/v1/push"
            }

            // Add queue configuration to handle out-of-order samples
            queue_config {
              capacity = 10000
              max_samples_per_send = 2000
              batch_send_deadline = "5s"
              min_shards = 1
              max_shards = 10
              retry_on_http_429 = true
            }

            external_labels = {
              cluster = "wanda",
              source = "alloy-wanda",
              alloy_instance = "wanda-cluster",
            }

            // Add metadata configuration
            metadata_config {
              send = true
              send_interval = "1m"
            }
          }

          // Kubernetes log collection
          discovery.kubernetes "pods_logs" {
            role = "pod"
          }

          // Pod logs collection
          loki.source.kubernetes "pod_logs" {
            targets    = discovery.kubernetes.pods_logs.targets
            forward_to = [loki.write.loki.receiver]
          }

          // Kubernetes events collection
          loki.source.kubernetes_events "cluster_events" {
            forward_to = [loki.write.loki.receiver]
          }

          // Remote write to Loki on tiny cluster
          loki.write "loki" {
            endpoint {
              url = "https://loki.tiny.heimelska.co.uk/loki/api/v1/push"
            }
            external_labels = {
              cluster = "wanda",
              source = "alloy-wanda",
            }
          }
