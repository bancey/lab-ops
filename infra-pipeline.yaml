trigger:
  batch: true
  branches:
    include:
      - main
  paths:
    exclude:
      - ansible/hosts.yaml
      - ansible/templates/frr.conf
      - kubernetes/*

pr:
  branches:
    include:
      - main
  paths:
    exclude:
      - ansible/hosts.yaml
      - ansible/templates/frr.conf

resources:
  repositories:
    - repository: azuredevops-lib
      type: github
      ref: refs/heads/main
      name: bancey/azuredevops-lib
      endpoint: bancey

parameters:
  - name: local_environments
    type: object
    default:
      - name: wanda
        address: "wanda.heimelska.co.uk"
      - name: thanos
        address: "thanos.heimelska.co.uk"
      - name: gamora
        address: "gamora.heimelska.co.uk"
      - name: hela
        address: "hela.heimelska.co.uk"
      - name: loki
        address: "loki.heimelska.co.uk"
      - name: thor
        address: "thor.heimelska.co.uk"
  - name: terraform_deployments
    type: object
    default:
      - deployment: generate_ansible_inventory
        environment: prod
        component: inventory
        destroy: false
        deploy: true
        preSteps:
          - task: AzureCLI@2
            displayName: Download GitHub Private Key
            condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
            inputs:
              azureSubscription: "MSDN New"
              scriptType: "bash"
              scriptLocation: "inlineScript"
              inlineScript: az keyvault secret download --name GitHub-Bot-Private-Key --vault-name bancey-vault --file $(System.DefaultWorkingDirectory)/private-key.pem
        dependsOn: []
      - deployment: prod_twingate
        environment: prod
        component: twingate
        destroy: false
        deploy: true
        dependsOn: []
      - deployment: prod_dns
        environment: prod
        component: dns
        destroy: false
        deploy: true
        localEnvironments:
          - thanos
          - gamora
        dependsOn:
          - prod_twingate
      - deployment: test_vpn_gateway
        environment: test
        component: cloud-vpn-gateway
        destroy: false
        deploy: true
        dependsOn: []
      - deployment: prod_vpn_gateway
        environment: prod
        component: cloud-vpn-gateway
        destroy: false
        deploy: true
        dependsOn:
          - test_vpn_gateway
      - deployment: test_gameserver
        environment: test
        component: game-server
        destroy: false
        deploy: true
        preSteps:
          task: AzureCLI@2
          displayName: Start Stopped VMs
          condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
          inputs:
            azureSubscription: "MSDN New"
            scriptType: "bash"
            addSpnToEnvironment: true
            scriptLocation: "inlineScript"
            inlineScript: |
              ids=$( az vm list -g games-test-rg --query "[[?powerState!='VM running'].id]" -d -o tsv)
              if [ -z "$ids" ]; then
                echo "No VMs to start"
              else
                echo "Starting VMs: $ids"
                az vm start --ids $ids
              fi
              echo "##vso[task.setvariable variable=testStoppedIds;isOutput=true]$ids"
        postStep:
          task: AzureCLI@2
          displayName: Stop VMs
          condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
          inputs:
            azureSubscription: "MSDN New"
            scriptType: "bash"
            addSpnToEnvironment: true
            scriptLocation: "inlineScript"
            inlineScript: |
              if [ -z "$(testStoppedIds)" ]; then
                echo "No VMs to start"
              else
                echo "Stopping VMs: $(testStoppedIds)"
                az vm stop --ids $(testStoppedIds)
                az vm deallocate --ids $(testStoppedIds)
              fi
        dependsOn:
          - prod_twingate
      - deployment: prod_gameserver
        environment: prod
        component: game-server
        destroy: false
        deploy: true
        preSteps:
          task: AzureCLI@2
          displayName: Start Stopped VMs
          condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
          inputs:
            azureSubscription: "MSDN New"
            scriptType: "bash"
            addSpnToEnvironment: true
            scriptLocation: "inlineScript"
            inlineScript: |
              ids=$( az vm list -g games-prod-rg --query "[[?powerState!='VM running'].id]" -d -o tsv)
              if [ -z "$ids" ]; then
                echo "No VMs to start"
              else
                echo "Starting VMs: $ids"
                az vm start --ids $ids
              fi
              echo "##vso[task.setvariable variable=prodStoppedIds]$ids"
        postStep:
          task: AzureCLI@2
          displayName: Stop VMs
          condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
          inputs:
            azureSubscription: "MSDN New"
            scriptType: "bash"
            addSpnToEnvironment: true
            scriptLocation: "inlineScript"
            inlineScript: |
              if [ -z "$(prodStoppedIds)" ]; then
                echo "No VMs to start"
              else
                echo "Stopping VMs: $(prodStoppedIds)"
                az vm stop --ids $(prodStoppedIds)
                az vm deallocate --ids $(prodStoppedIds)
              fi
        dependsOn:
          - prod_twingate
          - test_gameserver
      - deployment: wanda_virtual_machines
        environment: prod
        component: virtual-machines
        extraCommandArgs: -var "target_nodes=[\"wanda\"]"
        destroy: false
        deploy: true
        localEnvironments:
          - wanda
        dependsOn:
          - generate_ansible_inventory
        preSteps:
          - script: |
              sudo apt-get install age
              age --version
              curl -LO https://github.com/getsops/sops/releases/download/v3.10.2/sops-v3.10.2.linux.amd64
              mv sops-v3.10.2.linux.amd64 /usr/local/bin/sops
              chmod +x /usr/local/bin/sops
              sops --version
              mkdir -p ~/.config/sops/age
            displayName: Install SOPS and Age
          - task: AzureCLI@2
            displayName: Get Age Key
            inputs:
              azureSubscription: "MSDN New"
              scriptType: "bash"
              scriptLocation: "inlineScript"
              inlineScript: |
                az keyvault secret download --name Flux-Age-Key --vault-name bancey-vault --file ~/.config/sops/age/keys.txt
                chmod 600 ~/.config/sops/age/keys.txt
                ls -la ~/.config/sops/age
      - deployment: tiny_virtual_machines
        environment: prod
        component: virtual-machines
        extraCommandArgs: -var "target_nodes=[\"hela\",\"loki\",\"thor\"]"
        destroy: false
        deploy: true
        localEnvironments:
          - hela
          - loki
          - thor
        dependsOn:
          - generate_ansible_inventory
        preSteps:
          - script: |
              sudo apt-get install age
              age --version
              curl -LO https://github.com/getsops/sops/releases/download/v3.10.2/sops-v3.10.2.linux.amd64
              mv sops-v3.10.2.linux.amd64 /usr/local/bin/sops
              chmod +x /usr/local/bin/sops
              sops --version
              mkdir -p ~/.config/sops/age
            displayName: Install SOPS and Age
          - task: AzureCLI@2
            displayName: Get Age Key
            inputs:
              azureSubscription: "MSDN New"
              scriptType: "bash"
              scriptLocation: "inlineScript"
              inlineScript: |
                az keyvault secret download --name Flux-Age-Key --vault-name bancey-vault --file ~/.config/sops/age/keys.txt
                chmod 600 ~/.config/sops/age/keys.txt
                ls -la ~/.config/sops/age
  - name: ansible_deployments
    type: object
    default:
      - deployment: rpi_ansible
        environment: prod
        playbook: rpi-ha.yaml
        secrets:
          - keepalived-pass
          - Twingate-banceylab-connector-Refresh-Token
          - Twingate-banceylab-connector-Access-Token
          - Twingate-banceylab-connector-2-Refresh-Token
          - Twingate-banceylab-connector-2-Access-Token
          - BunkerWeb-DB-Password
          - BunkerWeb-TOTP-Secrets
          - BunkerWeb-MGMT-Admin-Username
          - BunkerWeb-MGMT-Admin-Password
          - Cloudflare-Lab-API-Token
        localEnvironments:
          - thanos
          - gamora
        dependsOn:
          - generate_ansible_inventory

variables:
  - name: agentImage
    value: ubuntu-latest
  - name: stateStorageAccount
    value: banceystatestor
  - name: serviceConnection
    value: "MSDN New"

stages:
  - template: stages/check-hosts-online.yaml@azuredevops-lib
    parameters:
      dependencies: prod_twingate
      keyVaultName: bancey-vault
      serviceKeySecretName: Twingate-AzureDevOps-SA-Key
      serviceConnection: $(serviceConnection)
      hosts: ${{ parameters.local_environments }}
  - ${{ each deployment in parameters.terraform_deployments }}:
      - stage: ${{ deployment.deployment }}
        ${{ if and(deployment.localEnvironments, gt(length(join('', deployment.dependsOn)), 0)) }}:
          dependsOn: ${{ split(format('{0},{1}', join(',', deployment.dependsOn), 'check_hosts_online'), ',') }}
        ${{ elseif deployment.localEnvironments }}:
          dependsOn: check_hosts_online
        ${{ else }}:
          dependsOn: ${{ deployment.dependsOn }}
        jobs:
          - ${{ if deployment.localEnvironments }}:
              - template: jobs/hosts-online-precheck.yaml@azuredevops-lib
                parameters:
                  localEnvironments: ${{ deployment.localEnvironments }}
          - job: TerraformPlanApply
            ${{ if deployment.localEnvironments }}:
              dependsOn: AllHostsOnlinePreCheck
              condition: and(succeeded(), eq(dependencies.AllHostsOnlinePreCheck.outputs['consolidate_hosts_online.allHostsOnline'], 'true'))
            ${{ else }}:
              condition: succeeded()
            pool:
              vmImage: $(agentImage)
            steps:
              - script: |
                  if [ "$(id -u)" -eq 0 ]; then
                    echo "Agent runs as root - will attempt direct Cache restore into /var"
                    echo "##vso[task.setvariable variable=can_write_apt]true"
                  else
                    echo "Agent does not run as root - will use workspace cache + sudo copy"
                    echo "##vso[task.setvariable variable=can_write_apt]false"
                  fi
                displayName: Check if agent can write to /var
                name: CheckAptWrite
              - script: |
                  set -e
                  # Compute a fingerprint of apt sources so cache invalidates when sources change
                  S=$( (find /etc/apt -maxdepth 2 -type f -name '*.list' -print0 2>/dev/null | sort -z | xargs -0 cat 2>/dev/null) || true )
                  if [ -z "$S" ]; then
                    H=no-sources
                  else
                    H=$(printf "%s" "$S" | md5sum | awk '{print $1}')
                  fi
                  echo "Computed apt sources hash: $H"
                  echo "##vso[task.setvariable variable=aptSourcesHash]$H"
                displayName: Compute APT sources fingerprint
              - ${{ if eq(variables['can_write_apt'], 'true') }}:
                  - task: Cache@2
                    displayName: "Restore APT lists (direct)"
                    inputs:
                      key: "apt-lists | $(Agent.OS) | $(aptSourcesHash)"
                      path: /var/lib/apt/lists
                  - task: Cache@2
                    displayName: "Restore APT archives (direct)"
                    inputs:
                      key: "apt-archives | $(Agent.OS) | $(aptSourcesHash)"
                      path: /var/cache/apt/archives
              - ${{ if ne(variables['can_write_apt'], 'true') }}:
                  - task: Cache@2
                    displayName: "Restore APT cache (workspace)"
                    inputs:
                      key: "apt | $(Agent.OS) | $(aptSourcesHash)"
                      path: $(Pipeline.Workspace)/apt-cache
                  - script: |
                      echo "Restoring APT cache into system locations (workspace fallback)"
                      if [ -d "$(Pipeline.Workspace)/apt-cache/archives" ]; then
                        sudo cp -a $(Pipeline.Workspace)/apt-cache/archives/* /var/cache/apt/archives/ || true
                      fi
                      if [ -d "$(Pipeline.Workspace)/apt-cache/lists" ]; then
                        sudo rm -rf /var/lib/apt/lists/* || true
                        sudo cp -a $(Pipeline.Workspace)/apt-cache/lists/* /var/lib/apt/lists/ || true
                      fi
                    displayName: Restore APT caches to /var (workspace fallback)
              - ${{ if deployment.preSteps }}:
                  - ${{ deployment.preSteps }}
              - ${{ if deployment.localEnvironments }}:
                  - template: steps/twingate-connect.yaml@azuredevops-lib
                    parameters:
                      keyVaultName: bancey-vault
                      serviceKeySecretName: Twingate-AzureDevOps-SA-Key
                      serviceConnection: $(serviceConnection)
              - ${{ if eq(deployment.component, 'virtual-machines') }}:
                  - template: steps/ansible.yaml@azuredevops-lib
                    parameters:
                      serviceConnection: $(serviceConnection)
                      keyVaultName: bancey-vault
                      privateKeySecretName: Packer-Private-Key
              - template: steps/terraform.yaml@azuredevops-lib
                parameters:
                  backendStorageAccount: $(stateStorageAccount)
                  workingDirectory: $(System.DefaultWorkingDirectory)/terraform/components/${{ deployment.component }}
                  azureRmKey: tfstate/${{ deployment.deployment }}.tfstate
                  serviceConnection: $(serviceConnection)
                  variableFilePath: $(System.DefaultWorkingDirectory)/terraform/environments/${{ deployment.environment }}/${{ deployment.environment }}.tfvars
                  ${{ if ne(deployment.extraCommandArgs, '') }}:
                    extraCommandArgs: ${{ deployment.extraCommandArgs }}
                  runApply: ${{ and(eq(deployment.deploy, true), eq(variables['Build.SourceBranch'], 'refs/heads/main')) }}
                  runDestroy: ${{ and(eq(deployment.destroy, true), eq(variables['Build.SourceBranch'], 'refs/heads/main')) }}
              - ${{ if ne(variables['can_write_apt'], 'true') }}:
                  - script: |
                      echo "Saving APT caches from system locations (workspace fallback)"
                      mkdir -p $(Pipeline.Workspace)/apt-cache/archives
                      sudo cp -a /var/cache/apt/archives/* $(Pipeline.Workspace)/apt-cache/archives/ || true
                      mkdir -p $(Pipeline.Workspace)/apt-cache/lists
                      sudo cp -a /var/lib/apt/lists/* $(Pipeline.Workspace)/apt-cache/lists/ || true
                      # Ensure the pipeline agent user owns the copied cache so subsequent steps can access it
                      sudo chown -R $(id -u):$(id -g) $(Pipeline.Workspace)/apt-cache || true
                    displayName: Save APT caches from /var (workspace fallback)
              - ${{ if deployment.postStep }}:
                  - ${{ deployment.postStep }}
  - ${{ each ansible_deployment in parameters.ansible_deployments }}:
      - stage: ${{ ansible_deployment.deployment }}
        ${{ if and(ansible_deployment.localEnvironments, gt(length(join('', ansible_deployment.dependsOn)), 0)) }}:
          dependsOn: ${{ split(format('{0},{1}', join(',', ansible_deployment.dependsOn), 'check_hosts_online'), ',') }}
        ${{ elseif ansible_deployment.localEnvironments }}:
          dependsOn: check_hosts_online
        ${{ else }}:
          dependsOn: ${{ ansible_deployment.dependsOn }}
        jobs:
          - ${{ if ansible_deployment.localEnvironments }}:
              - template: jobs/hosts-online-precheck.yaml@azuredevops-lib
                parameters:
                  localEnvironments: ${{ ansible_deployment.localEnvironments }}
              - job: AnsibleCheckRun
                ${{ if ansible_deployment.localEnvironments }}:
                  dependsOn: AllHostsOnlinePreCheck
                  condition: and(succeeded(), eq(dependencies.AllHostsOnlinePreCheck.outputs['consolidate_hosts_online.allHostsOnline'], 'true'))
                ${{ else }}:
                  condition: succeeded()
                pool:
                  vmImage: $(agentImage)
                steps:
                  - script: |
                      if [ "$(id -u)" -eq 0 ]; then
                        echo "Agent runs as root - will attempt direct Cache restore into /var"
                        echo "##vso[task.setvariable variable=can_write_apt]true"
                      else
                        echo "Agent does not run as root - will use workspace cache + sudo copy"
                        echo "##vso[task.setvariable variable=can_write_apt]false"
                      fi
                    displayName: Check if agent can write to /var
                    name: CheckAptWrite
                  - script: |
                      set -e
                      S=$( (find /etc/apt -maxdepth 2 -type f -name '*.list' -print0 2>/dev/null | sort -z | xargs -0 cat 2>/dev/null) || true )
                      if [ -z "$S" ]; then
                        H=no-sources
                      else
                        H=$(printf "%s" "$S" | md5sum | awk '{print $1}')
                      fi
                      echo "Computed apt sources hash: $H"
                      echo "##vso[task.setvariable variable=aptSourcesHash]$H"
                    displayName: Compute APT sources fingerprint
                  - ${{ if eq(variables['can_write_apt'], 'true') }}:
                      - task: Cache@2
                        displayName: "Restore APT lists (direct)"
                        inputs:
                          key: "apt-lists | $(Agent.OS) | $(aptSourcesHash)"
                          path: /var/lib/apt/lists
                      - task: Cache@2
                        displayName: "Restore APT archives (direct)"
                        inputs:
                          key: "apt-archives | $(Agent.OS) | $(aptSourcesHash)"
                          path: /var/cache/apt/archives
                  - ${{ if ne(variables['can_write_apt'], 'true') }}:
                      - task: Cache@2
                        displayName: "Restore APT cache (workspace)"
                        inputs:
                          key: "apt | $(Agent.OS) | $(aptSourcesHash)"
                          path: $(Pipeline.Workspace)/apt-cache
                      - script: |
                          echo "Restoring APT cache into system locations (workspace fallback)"
                          if [ -d "$(Pipeline.Workspace)/apt-cache/archives" ]; then
                            sudo cp -a $(Pipeline.Workspace)/apt-cache/archives/* /var/cache/apt/archives/ || true
                          fi
                          if [ -d "$(Pipeline.Workspace)/apt-cache/lists" ]; then
                            sudo rm -rf /var/lib/apt/lists/* || true
                            sudo cp -a $(Pipeline.Workspace)/apt-cache/lists/* /var/lib/apt/lists/ || true
                          fi
                        displayName: Restore APT caches to /var (workspace fallback)
                  - template: steps/twingate-connect.yaml@azuredevops-lib
                    parameters:
                      keyVaultName: bancey-vault
                      serviceKeySecretName: Twingate-AzureDevOps-SA-Key
                      serviceConnection: $(serviceConnection)
                  - template: steps/ansible.yaml@azuredevops-lib
                    parameters:
                      serviceConnection: $(serviceConnection)
                      keyVaultName: bancey-vault
                      privateKeySecretName: Packer-Private-Key
                      playbook: ${{ ansible_deployment.playbook }}
                      secrets: ${{ ansible_deployment.secrets }}
                      requirementsFile: ${{ ansible_deployment.requirementsFile }}
                  - ${{ if ne(variables['can_write_apt'], 'true') }}:
                      - script: |
                          echo "Saving APT caches from system locations (workspace fallback)"
                          mkdir -p $(Pipeline.Workspace)/apt-cache/archives
                          sudo cp -a /var/cache/apt/archives/* $(Pipeline.Workspace)/apt-cache/archives/ || true
                          mkdir -p $(Pipeline.Workspace)/apt-cache/lists
                          sudo cp -a /var/lib/apt/lists/* $(Pipeline.Workspace)/apt-cache/lists/ || true
                          # Ensure the pipeline agent user owns the copied cache so subsequent steps can access it
                          sudo chown -R $(id -u):$(id -g) $(Pipeline.Workspace)/apt-cache || true
                        displayName: Save APT caches from /var (workspace fallback)
